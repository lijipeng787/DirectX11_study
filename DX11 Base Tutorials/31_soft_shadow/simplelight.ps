Texture2D shaderTexture;
SamplerState SampleType;

cbuffer LightBuffer {
	float4 ambientColor;
	float4 diffuseColor;
	float3 lightDirection;
	float padding;
};

struct PixelInputType{
    float4 position : SV_POSITION;
    float2 tex : TEXCOORD0;
	float3 normal : NORMAL;
};

float4 SimpleLightPixelShader(PixelInputType input) : SV_TARGET{

	float4 textureColor;
	float3 normal;
	float3 lightDir;
	float lightIntensity;
	float4 color;

	// Sample texture color
	textureColor = shaderTexture.Sample(SampleType, input.tex);
	
	// Renormalize normal (may not be unit vector after rasterization interpolation)
	// This is important for accurate dot product calculation, ensuring correct lighting
	normal = normalize(input.normal);
	
	// Initialize color with ambient light
	color = ambientColor;
	
	// Calculate light direction (negated, because directional light points towards source)
	// Normalize light direction to ensure correctness (even if input may already be unit vector)
	lightDir = normalize(-lightDirection);
	
	// Calculate diffuse lighting intensity, use saturate to clamp to [0, 1] range
	// saturate automatically handles negative values (backlit faces), no if branch needed, improves performance
	lightIntensity = saturate(dot(normal, lightDir));
	
	// Add diffuse lighting contribution
	color += (diffuseColor * lightIntensity);
	
	// Clamp final color to valid range
	color = saturate(color);
	
	// Multiply lighting result with texture color
	color = color * textureColor;
	
	return color;
}

